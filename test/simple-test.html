<html>

<body></body>
<script src="../build/bulletml.js"></script>
<script src="./stats.min.js"></script>
<script>
	const disp = true;

	window.onload = async () => {
		const res = await fetch("samples.json");
		const json = await res.json();
		const xmlName = json[Math.floor(Math.random() * json.length)];
		// const xmlName = "./sample/[Original]_tsunami.xml";
		console.log(xmlName);
		const xml = await load(xmlName);
		// console.log(xml);
		main(xml);
	};

	const load = async (url) => {
		const res = await fetch(url);
		return await res.text();
	};

	const key = {
		ArrowRight: false,
		ArrowLeft: false,
		ArrowUp: false,
		ArrowDown: false,
	};
	window.onkeydown = (e) => {
		key[e.key] = true;
	};
	window.onkeyup = (e) => {
		key[e.key] = false;
	};

	const main = (xml) => {
		const scale = 4;
		const radius = 10;
		const canvas = document.createElement("canvas");
		canvas.width = 400 * scale;
		canvas.height = 400 * scale;
		canvas.style.width = "512px";
		canvas.style.marginLeft = "100px";
		document.body.appendChild(canvas);
		const context = canvas.getContext("2d");

		const root = BulletML.parse(xml);
		// console.log(root);

		const player = { x: canvas.width * 0.5 / scale, y: canvas.height * 0.8 / scale };

		const enemy = new BulletML.Bullet();
		enemy.x = canvas.width * 0.5 / scale;
		enemy.y = canvas.height * 0.3 / scale;

		const bullets = [];

		const manager = new BulletML.Manager({ player });
		manager.rank = 1.0;
		manager.onFire = (params) => {
			const { bullet, runner, spec } = params;
			bullets.push(bullet);
			bullet.onVanish = () => {
				const idx = bullets.indexOf(bullet);
				if (idx >= 0) bullets.splice(idx, 1);
			};
		};
		manager.run(enemy, root);

		const stats = new Stats();
		stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
		document.body.appendChild(stats.dom);

		const loop = () => {
			stats.begin();

			manager.update();

			bullets.forEach(bullet => {
				if (bullet.x * scale < 0 || canvas.width <= bullet.x * scale || bullet.y * scale < 0 || canvas.height <= bullet.y * scale) {
					bullet.destroy();
					const idx = bullets.indexOf(bullet);
					if (idx >= 0) bullets.splice(idx, 1);
				}
			});

			context.fillStyle = "white";
			context.fillRect(0, 0, canvas.width, canvas.height);

			if (disp) {

				context.save();
				context.translate(player.x * scale, player.y * scale);
				context.fillStyle = "black";
				context.fillRect(-radius, -radius, radius * 2, radius * 2);
				context.restore();

				context.fillStyle = "red";
				bullets.forEach(bullet => {
					context.save();
					context.translate(bullet.x * scale, bullet.y * scale);
					context.fillRect(-radius, -radius, radius * 2, radius * 2);
					context.restore();
				});

				if (key.ArrowLeft) {
					player.x -= 0.5 * scale;
				} else if (key.ArrowRight) {
					player.x += 0.5 * scale;
				}
				if (key.ArrowUp) {
					player.y -= 0.5 * scale;
				} else if (key.ArrowDown) {
					player.y += 0.5 * scale;
				}

			}

			context.fillStyle = "black";
			context.font = "40px monospace";
			context.fillText("Runner.pool.count = " + BulletML.Runner.pool.getCount(), 10, 50 * 1);
			context.fillText("Bullet.pool.count = " + BulletML.Bullet.pool.getCount(), 10, 50 * 2);
			context.fillText("manager.runners.length = " + manager.runners.length, 10, 50 * 3);

			stats.end();

			requestAnimationFrame(loop);
		};
		loop();
	};
</script>

</html>